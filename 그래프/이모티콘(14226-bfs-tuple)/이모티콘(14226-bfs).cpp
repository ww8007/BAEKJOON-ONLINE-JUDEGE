//백준 : 이모티콘 14226번 bfs
//
//문제 
//
//영선이는 매우 기쁘기 때문에, 효빈이에게 스마일 이모티콘을 S개 보내려고 한다.
//
//영선이는 이미 화면에 이모티콘 1개를 입력했다.이제, 다음과 같은 3가지 연산만 사용해서 이모티콘을 S개 만들어 보려고 한다.
//
//화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장한다.
//클립보드에 있는 모든 이모티콘을 화면에 붙여넣기 한다.
//화면에 있는 이모티콘 중 하나를 삭제한다.
//모든 연산은 1초가 걸린다.또, 클립보드에 이모티콘을 복사하면 이전에 클립보드에 있던 내용은 덮어쓰기가 된다.
//클립보드가 비어있는 상태에는 붙여넣기를 할 수 없으며, 일부만 클립보드에 복사할 수는 없다.또한, 
//클립보드에 있는 이모티콘 중 일부를 삭제할 수 없다.화면에 이모티콘을 붙여넣기 하면, 클립보드에 있는 이모티콘의 개수가 화면에 추가된다.
//영선이가 S개의 이모티콘을 화면에 만드는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.
//
//입력 
//
//첫째 줄에 S(2 ≤ S ≤ 1000) 가 주어진다.
//2
//출력
//
//첫째 줄에 이모티콘을 S개 만들기 위해 필요한 시간의 최솟값을 출력한다.
//2
//풀이

// 요번 알고리즘에서는 tuple을 이용한 tie(x, y) = q.front();
// 이것이 처음으로 나왔다. 
// 큐에 pair로 값을 집어 넣고 memset을 이용한 배열을 -1로 채운 뒤 이것을 -1이 
// 아닌 값들을 찾는게 요번 알고리즘의 관건 이였다.
#include <iostream>
#include <queue>
#include <cstdio>
#include <tuple>

using namespace std;

int d[1001][1001];

int main(void)
{
	int num;
	cin >> num;
	memset(d, -1, sizeof(d));
	queue <pair<int, int>> q;
	q.push(make_pair(1, 0));
	d[1][0] = 0;
	while (!q.empty())
	{
		int x, y;
		tie(x, y) = q.front();
		q.pop();
		if (d[x][x] == -1)
		{
			d[x][x] = d[x][y] + 1;
			q.push(make_pair(x, x));
		}
		if (x + y <= num && d[x + y][y] == -1)
		{
			d[x + y][y] = d[x][y] + 1;
			q.push(make_pair(x + y, y));
		}
		if (x - 1 >= 0 && d[x - 1][y] == -1)
		{
			d[x - 1][y] = d[x][y] + 1;
			q.push(make_pair(x - 1, y));
		}
	}
	int ans = -1;
	for (int i = 0; i <= num; i++)
	{
		if (d[num][i] != -1)
		{
			if (ans == -1 || ans > d[num][i])
			{
				ans = d[num][i];
			}
		}
	}
	cout << ans << '\n';
	return 0;
}